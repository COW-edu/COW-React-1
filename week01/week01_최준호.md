# HTML과CSS / 브라우저와 CRP

## HTML (Hypertext Markup Language)

- 웹페이지가 어떻게 구조화 되어 있는지 브라우저가 알 수 있도록 하는 마크업 언어
- 요소(elements) 와 속성(attribute)를 가진다.
- 블록 레벨 요소와 인라인 요소 두 가지의 종류가 있다.
    - 블록 레벨 요소 :
        - 앞 뒤 요소 사이에 새로운 줄을 만들고 나온다.
        - 페이지의 구조적 요소를 나타낼 때 사용된다.
        - 단락, 목록, 네비게이션 메뉴 등등을 표현할 때 사용
    - 인라인 요소:
        - 새로운 줄을 만들어내지 않고 작성한 단락내에 나타나게 된다.
        - 링크 정의, 텍스트 강조 등에 사용된다.

---

## CSS

- 사용자에게 문서를 표시하는 방법을 지정하는 언어(스타일, 레이아웃 등)
- 규칙 기반의 언어 → 특정 요소, 요소 그룹에 적용할 스타일을 지정하는 규칙을 정의하는 언어이다.
- 브라우저가 이해하지 못하는 속성, 값 발견시 무시하고 넘어감→ 적용x (철자 오류, 속성 선택자 오류, 브라우저 미지원 등)

---

## 브라우저

- 웹에서 페이지를 검색하고 표시하며 사용자가 하이퍼링크를 통해 추가 페이지에 접근할 수 있도록 하는 프로그램
- **사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다.**
    - 자원 : 보통 HTML이나 PDF나 이미지 파일 등 일 수 있다.
        
        → URI(Uniform Resource Identifier)에 의해 정해진다.
        
- HTML과 CSS명세에 따라 HTML파일을 해석해서 표시 → W3C에서 명세를 정한다.
- 브라우저 기본구조 ⇒
    1. 사용자 인터페이스 : 주소 표시줄, 이전/다음버튼 등 요청한 페이지를 제외한 나머지 부분
    2. 브라우저 엔진 : 사용자 인터페이스와 렌더링 엔진 중간, 동작 제어 역할
    3. 렌더링 엔진 : 요청한 콘텐츠를 표시
        1. 통신을 제외한 거의 모든 경우 단일 스레드로 동작
        2. 브라우저의 주요 스레드는 이벤트 순환으로 처리 과정을 유지하기 위해 무한 순환된다.
    4. 통신 : HTTP 요청과 같은 네트워크 호출에 사용된다.
        
        → 플랫폼 독립적 인터페이스, 플랫폼 하부에서 실행
        
    5. UI 백엔드 : 기본적인 장치 그림(콤보박스같은거), OS 사용자 인터페이스 체계를 사용한다.
        1. 콤보박스→ 여러 선택지 중 하나를 선택할 때 사용하는 요소
    6. 자바스크립트 해석기 : 자바스크립트 코드를 해석하고 실행
    7. 자료 저장소 : 자료를 저장하는 계층, 쿠키 저장처럼 모든 종류의 자원을 하드디스크에 저장할 필요가 있다.

![브라우저 기본 구조](https://github.com/COW-edu/COW-React-1/assets/127816010/4db86757-c797-40d7-9ed1-c386d0437a10)

브라우저 기본 구조

---

## CRP : 중요 랜더링 경로

- Critical Rendering Path
- 브라우저가 HTML, CSS, Javascript를 화면에 픽셀로 변화하는 일련의 단계
- 최적화 시 렌더링 성능을 향상시킨다.
- DOM트리 구축 → CSSOM트리 구축 → Render트리 구축 → 레이아웃 생성 → 페인팅 순서로 진행된다.

![https://github.com/COW-edu/COW-23-Basic/assets/127816010/d03976ec-5a10-4df4-b895-8dc2a2101cf0](https://github.com/COW-edu/COW-23-Basic/assets/127816010/d03976ec-5a10-4df4-b895-8dc2a2101cf0)

### DOM트리 구축

- HTML의 요청 → 각각의 요소와 텍스트에 대한 노드 생성 → 중첩된 요소는 자식 노드로 표현 & 각 노드에 해당 요소 특성 포함된다.
- 노드의 서열에 따라 DOM트리에 연결된다.

![DOM TREE 예시](https://github.com/COW-edu/COW-23-Basic/assets/127816010/e82c29c7-21b8-46ee-be1a-1e92128a3b4d)

DOM TREE 예시

### CSSOM트리 구축

- CSS를 파싱하며 구축된다.
- CSSOM을 구성하는 노드들은 부모의 속성을 상속받는다.
    
    ex) 부모가 font-size속성을 가지면 자식도 동일한 속성을 추가한다.
    
- 브라우저가 모든 CSS를 수신할때 까지 페이지 렌더링을 막는다.
    
    ⇒ <head> 안에 CSS를 정의하여 빠르게 리소스를 받을 수 있도록 하는 이유이다.
    
- JS에서 스타일 정보 요청 시 CSS가 파싱되지 않는다면 스크립트 에러 발생한다.

![CSSOM TREE 예시](https://github.com/COW-edu/COW-23-Basic/assets/127816010/98438c70-3c86-4909-8e5a-1483544d5d7b)

CSSOM TREE 예시

<aside>
<img src="https://www.notion.so/icons/info-alternate_gray.svg" alt="https://www.notion.so/icons/info-alternate_gray.svg" width="40px" /> JavaScript : 문서를 파싱하다가 JS를 만나면 진행하던 파싱을 멈추고 자바스크립트 엔진에게 권한 넘겨 자바스크립트 먼저 파싱하고 실행한다.
→ 파싱을 중단시키기에 <body> 태그 닫히기 바로 직전에 넣어서 사용한다.

</aside>

### Render트리 구축

- DOM 트리와 CSSOM트리를 Render트리에 결합시킨다.
- 화면에 보여지는 부분만 가져온다.
    
    ex) `display: none` , `<head>` 부분은 보여지지 않기에 렌더트리에 포함하지 않는다.
    

### Layout

- 요소들이 페이지에서 배치되는 위치, 방법, 크기 등 스타일을 결정하는 과정
- 모든 노드들은 자식 노드들의 레이아웃을 배치, 모든 자식 노드들이 레이아웃 결정 될 때까지 반복 ⇒ 특정 부모 노드에게 레이아웃 발생 시 자식 노드도 레이아웃이 발생되기에 성능 저하
- 레이아웃 이벤트의 반복과 형성시간을 줄이기 위해서 일괄 업데이트 해야하며, 박스 모델 속성을 애니메이션화 하지 않는 방법이 있다.

### Paint

- 화면 픽셀을 그리는 단계
- 렌더트리를 순회하며 레이어(Layer)만들고, 레이어 채우는 과정(배경, 텍스트, 순서 등)을 기록
    - 레이어 만드는 이유 : 화면에 그리는 순서를 보장하기 위함(`z-index` , `position` 에 의한 속성을 따르기 위해서)
- 레이어를 페인팅 한 후 하나의 이미지로 합쳐(합성 : `Composite`) 브라우저에 표현된다.

<aside>
❓ **!! 파싱 !!**

- 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것
- 문서에 작성된 언어 또는 형식의 규칙을 따르는데 모든 파싱 가능한 형식은 정해진 용어와 구문 규칙을 따른다. ⇒ `문맥 자유 문법`
- 어휘 분석, 구문 분석으로 나눌 수 있음
- 어휘 분석 : 자료를 토큰으로 분해하는 과정 / 구문 분석 : 언어의 구문 규칙을 적용하는 과정
- 파서 : 어휘 분석간 유효한 토큰으로 분해하는 어휘 분석기, 구문 규칙에 따라 문서 구조를 분석하여 파싱 트리를 생성하는 파서가 있다.
- HTML은 문맥 자유 문법이 아니지만 CSS와 JS는 문맥 자유 문법이기에 정규 파서로 파싱 가능하다.
    - HTML은 전통적인 파서가 아닌 HTML파서를 통해 파싱 트리로 변환된다
</aside>

---

## 리플로우 & 리페인트

- 리플로우 : DOM요소의 기하학적 속성(`width` `height` 등등) & 브라우저 크기 변화 등에 의해 렌더트리 재생성하는 작업이며 리페인트 작업 또한 같이 실행된다.
    - 비용이 큰 작업 : 리플로우 발생시 주변 요소(부모, 형제, 자식 노드)에도 영향을 주기 때문이다.
    
    ⇒ JS/CSS파싱 → Render트리 구축 → 레이아웃 → 리페인트 → 합성
    
- 리페인트 : 변경된 요소를 화면에 그려주는 작업, 글자색 변경이나 `hidden -> visible`로 변화시 실행
    
    ⇒ JS/CSS파싱 → Render트리 구축 → 리페인트 → 합성
    

### 리플로우는 언제 발생하는가?

- 페이지 초기 렌더링시
- 윈도우 리사이징
- 스타일의 동적 변화
- 요소의 위치, 크기 변경
- 노드의 추가 제거

등등

### 리플로우의 영향을 최소화 하기 위한 방법

- DOM구조 상 말단노드에만 클래스를 사용하여 리플로우 영향을 최소화 하며 비용을 줄인다.
- 인라인 스타일 사용시 리플로우가 수차례 발생하기에 자제하며 클래스를 사용하도록 한다.
- `position : relative` 를 주의한다.
- 애니메이션 `position`을 `absolute` `fixed`로 하여 주변 레이아웃에 영향을 주지 않도록 한다.
- 리플로우 유발 함수 호출 제한하기
- 불필요한 DOM Tree 깊이 줄이기
- CSS규칙 최소화 및 사용되지 않는 CSS규칙 삭제

기타 등등… 
- 참고자료 ->
https://lists.w3.org/Archives/Public/public-html-ig-ko/2011Sep/att-0031/Reflow_____________________________Tip.pdf
